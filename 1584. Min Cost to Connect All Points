class Solution {
    class Pair {
        int node;
        int md;

        Pair(int node, int md) {
            this.node = node;
            this.md = md;
        }
    }

    class Trip {
        int node;
        int par;
        int md;

        Trip(int node, int par, int md) {
            this.node = node;
            this.par = par;
            this.md = md;

        }

    }

    public int minCostConnectPoints(int[][] points) {
        int sum = 0;
        boolean[] vis = new boolean[points.length];
        PriorityQueue<Trip> h = new PriorityQueue<>((a, b) -> a.md - b.md);
        h.add(new Trip(0, -1, 0));
        while (h.size() > 0) {
            Trip top = h.remove();
            if (vis[top.node] == true)
                continue;
            vis[top.node] = true;
            if (top.par != -1)
                sum = sum + top.md;
            for (int i = 0; i < points.length; i++) {
                if (top.node == i)
                    continue;
                int matDis = Math.abs(points[top.node][0] - points[i][0])
                        + Math.abs(points[top.node][1] - points[i][1]);
                if (vis[i] == false)
                    h.add(new Trip(i, top.node, matDis));
            }
        }
        return sum;
    }
}
